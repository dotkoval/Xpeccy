# Generated by ChatGPT 4o

import tkinter as tk
from PIL import Image, ImageTk
import socket

# Настройки подключения
UDP_IP = "192.168.0.82"  # IP-адрес сервера
UDP_PORT = 16384      # Порт, на котором сервер отправляет данные

# Создаём UDP сокет
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Отправляем первое сообщение для "подключения" к серверу
sock.sendto(b"Hello, server", (UDP_IP, UDP_PORT))

print(f"Listening for UDP data from {UDP_IP}:{UDP_PORT}...")

# Параметры изображения
width, height = 256, 192

# Цветовая палитра ZX Spectrum (яркий и обычный режим)
spectrum_palette = [
    (0, 0, 0),  # Black
    (0, 0, 192),  # Blue
    (192, 0, 0),  # Red
    (192, 0, 192),  # Magenta
    (0, 192, 0),  # Green
    (0, 192, 192),  # Cyan
    (192, 192, 0),  # Yellow
    (192, 192, 192),  # White
    (0, 0, 0),  # Bright Black
    (0, 0, 255),  # Bright Blue
    (255, 0, 0),  # Bright Red
    (255, 0, 255),  # Bright Magenta
    (0, 255, 0),  # Bright Green
    (0, 255, 255),  # Bright Cyan
    (255, 255, 0),  # Bright Yellow
    (255, 255, 255)  # Bright White
]

def zx_spectrum_to_rgb(data, attrs):
    """
    Преобразует экран ZX Spectrum (6144 байта данных и 768 байт атрибутов) в RGB формат.
    :param data: 6144 байт данных, представляющих битмап ZX Spectrum.
    :param attrs: 768 байт атрибутов для 8x8 блоков.
    :return: Линейный массив пикселей в формате RGB.
    """
    pixels = []

    for y in range(height):
        row = (y & 0xC0) >> 6
        group = (y & 0x38) >> 3
        line = y & 0x07
        addr = (row << 11) | (line << 8) | (group << 5)

        for x in range(32):  # 32 байта на строку
            byte = data[addr + x]

            # Определяем атрибут для данного блока 8x8
            attr_index = (y // 8) * 32 + x
            attr = attrs[attr_index]

            # Извлекаем цвет фона и переднего плана
            ink = attr & 0x07  # Цвет переднего плана (3 младших бита)
            paper = (attr >> 3) & 0x07  # Цвет фона (следующие 3 бита)
            bright = (attr >> 6) & 0x01  # Яркость

            # Выбираем цвета из палитры
            foreground = spectrum_palette[ink + bright * 8]
            background = spectrum_palette[paper + bright * 8]

            # Переводим байт в 8 пикселей
            for bit in range(8):
                # Если бит установлен, то передний план, иначе фон
                if byte & (1 << (7 - bit)):  # Проверяем, установлен ли бит
                    pixels.append(foreground)  # Добавляем кортеж RGB переднего плана
                else:
                    pixels.append(background)  # Добавляем кортеж RGB фона

    return pixels

def update_image():
    # Получаем данные от сервера
    data, addr = sock.recvfrom(8192)  # Буфер размером 8 кбайт
    #print(f"Received data from {addr}: {len(data)} bytes")

    # Преобразуем данные ZX Spectrum в линейный массив пикселей
    #pixels = zx_spectrum_to_linear(data)

    # Разделяем данные на битмап (6144 байт) и атрибуты (768 байт)
    bitmap_data = data[:6144]
    attr_data = data[6144:6144 + 768]

    # Преобразуем данные ZX Spectrum в линейный массив пикселей (RGB)
    pixels = zx_spectrum_to_rgb(bitmap_data, attr_data)

    # Создаем изображение в формате L (градации серого)
    #img = Image.new('L', (width, height))

    # Создаем изображение в формате RGB
    img = Image.new('RGB', (width, height))
    img.putdata(pixels)

    # Увеличиваем изображение в 2 раза
    img = img.resize((width * 2, height * 2), Image.NEAREST)  # Масштабируем в 200%


    # Преобразуем изображение для Tkinter
    tk_img = ImageTk.PhotoImage(img)

    # Обновляем изображение в виджете
    label.config(image=tk_img)
    label.image = tk_img

    # Рекурсивно вызываем обновление каждые 15 мс (чуть чаще 60fps, для запаса)
    root.after(15, update_image)

# Создаем главное окно Tkinter
root = tk.Tk()
root.title("UDP Image Stream")

# Создаем метку для отображения изображения
label = tk.Label(root)
label.pack()

# Запускаем первый вызов функции обновления изображения
update_image()

# Запускаем главный цикл приложения
root.mainloop()
